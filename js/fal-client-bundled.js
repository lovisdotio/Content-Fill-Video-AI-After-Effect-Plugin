/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@fal-ai/client/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/package.json ***!
  \**************************************************/
/***/ ((module) => {

eval("{module.exports = /*#__PURE__*/JSON.parse('{\"name\":\"@fal-ai/client\",\"description\":\"The fal.ai client for JavaScript and TypeScript\",\"version\":\"1.6.1\",\"license\":\"MIT\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/fal-ai/fal-js.git\",\"directory\":\"libs/client\"},\"keywords\":[\"fal\",\"client\",\"ai\",\"ml\",\"typescript\"],\"exports\":{\".\":\"./src/index.js\",\"./endpoints\":\"./src/types/endpoints.js\"},\"typesVersions\":{\"*\":{\"endpoints\":[\"src/types/endpoints.d.ts\"]}},\"main\":\"./src/index.js\",\"types\":\"./src/index.d.ts\",\"dependencies\":{\"@msgpack/msgpack\":\"^3.0.0-beta2\",\"eventsource-parser\":\"^1.1.2\",\"robot3\":\"^0.4.1\"},\"engines\":{\"node\":\">=18.0.0\"},\"type\":\"commonjs\"}');\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/package.json?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/auth.js":
/*!*************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/auth.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TOKEN_EXPIRATION_SECONDS = void 0;\nexports.getTemporaryAuthToken = getTemporaryAuthToken;\nconst config_1 = __webpack_require__(/*! ./config */ \"./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\nexports.TOKEN_EXPIRATION_SECONDS = 120;\n/**\n * Get a token to connect to the realtime endpoint.\n */\nfunction getTemporaryAuthToken(app, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const appId = (0, utils_1.parseEndpointId)(app);\n        const token = yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/tokens/`,\n            config,\n            input: {\n                allowed_apps: [appId.alias],\n                token_expiration: exports.TOKEN_EXPIRATION_SECONDS,\n            },\n        });\n        // keep this in case the response was wrapped (old versions of the proxy do that)\n        // should be safe to remove in the future\n        if (typeof token !== \"string\" && token[\"detail\"]) {\n            return token[\"detail\"];\n        }\n        return token;\n    });\n}\n//# sourceMappingURL=auth.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/auth.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/client.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFalClient = createFalClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"./node_modules/@fal-ai/client/src/config.js\");\nconst queue_1 = __webpack_require__(/*! ./queue */ \"./node_modules/@fal-ai/client/src/queue.js\");\nconst realtime_1 = __webpack_require__(/*! ./realtime */ \"./node_modules/@fal-ai/client/src/realtime.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"./node_modules/@fal-ai/client/src/storage.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"./node_modules/@fal-ai/client/src/streaming.js\");\n/**\n * Creates a new reference of the `FalClient`.\n * @param userConfig Optional configuration to override the default settings.\n * @returns a new instance of the `FalClient`.\n */\nfunction createFalClient(userConfig = {}) {\n    const config = (0, config_1.createConfig)(userConfig);\n    const storage = (0, storage_1.createStorageClient)({ config });\n    const queue = (0, queue_1.createQueueClient)({ config, storage });\n    const streaming = (0, streaming_1.createStreamingClient)({ config, storage });\n    const realtime = (0, realtime_1.createRealtimeClient)({ config });\n    return {\n        queue,\n        realtime,\n        storage,\n        streaming,\n        stream: streaming.stream,\n        run(endpointId_1) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, options = {}) {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, options),\n                    input: input,\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: options.abortSignal,\n                        retry: {\n                            maxRetries: 3,\n                            baseDelay: 500,\n                            maxDelay: 15000,\n                        },\n                    },\n                });\n            });\n        },\n        subscribe: (endpointId, options) => __awaiter(this, void 0, void 0, function* () {\n            const { request_id: requestId } = yield queue.submit(endpointId, options);\n            if (options.onEnqueue) {\n                options.onEnqueue(requestId);\n            }\n            yield queue.subscribeToStatus(endpointId, Object.assign({ requestId }, options));\n            return queue.result(endpointId, { requestId });\n        }),\n    };\n}\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/client.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.credentialsFromEnv = void 0;\nexports.resolveDefaultFetch = resolveDefaultFetch;\nexports.createConfig = createConfig;\nexports.getRestApiUrl = getRestApiUrl;\nconst middleware_1 = __webpack_require__(/*! ./middleware */ \"./node_modules/@fal-ai/client/src/middleware.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst retry_1 = __webpack_require__(/*! ./retry */ \"./node_modules/@fal-ai/client/src/retry.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"./node_modules/@fal-ai/client/src/runtime.js\");\nfunction resolveDefaultFetch() {\n    if (typeof fetch === \"undefined\") {\n        throw new Error(\"Your environment does not support fetch. Please provide your own fetch implementation.\");\n    }\n    return fetch;\n}\n/**\n * Checks if the required FAL environment variables are set.\n *\n * @returns `true` if the required environment variables are set,\n * `false` otherwise.\n */\nfunction hasEnvVariables() {\n    return (typeof process !== \"undefined\" &&\n        process.env &&\n        (typeof process.env.FAL_KEY !== \"undefined\" ||\n            (typeof process.env.FAL_KEY_ID !== \"undefined\" &&\n                typeof process.env.FAL_KEY_SECRET !== \"undefined\")));\n}\nconst credentialsFromEnv = () => {\n    if (!hasEnvVariables()) {\n        return undefined;\n    }\n    if (typeof process.env.FAL_KEY !== \"undefined\") {\n        return process.env.FAL_KEY;\n    }\n    return process.env.FAL_KEY_ID\n        ? `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`\n        : undefined;\n};\nexports.credentialsFromEnv = credentialsFromEnv;\nconst DEFAULT_CONFIG = {\n    credentials: exports.credentialsFromEnv,\n    suppressLocalCredentialsWarning: false,\n    requestMiddleware: (request) => Promise.resolve(request),\n    responseHandler: response_1.defaultResponseHandler,\n    retry: retry_1.DEFAULT_RETRY_OPTIONS,\n};\n/**\n * Configures the fal client.\n *\n * @param config the new configuration.\n */\nfunction createConfig(config) {\n    var _a;\n    let configuration = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : resolveDefaultFetch(), \n        // Merge retry configuration with defaults\n        retry: Object.assign(Object.assign({}, retry_1.DEFAULT_RETRY_OPTIONS), (config.retry || {})) });\n    if (config.proxyUrl) {\n        configuration = Object.assign(Object.assign({}, configuration), { requestMiddleware: (0, middleware_1.withMiddleware)(configuration.requestMiddleware, (0, middleware_1.withProxy)({ targetUrl: config.proxyUrl })) });\n    }\n    const { credentials: resolveCredentials, suppressLocalCredentialsWarning } = configuration;\n    const credentials = typeof resolveCredentials === \"function\"\n        ? resolveCredentials()\n        : resolveCredentials;\n    if ((0, runtime_1.isBrowser)() && credentials && !suppressLocalCredentialsWarning) {\n        console.warn(\"The fal credentials are exposed in the browser's environment. \" +\n            \"That's not recommended for production use cases.\");\n    }\n    return configuration;\n}\n/**\n * @returns the URL of the fal REST api endpoint.\n */\nfunction getRestApiUrl() {\n    return \"https://rest.alpha.fal.ai\";\n}\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/config.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fal = exports.parseEndpointId = exports.isRetryableError = exports.ValidationError = exports.ApiError = exports.withProxy = exports.withMiddleware = exports.createFalClient = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/@fal-ai/client/src/client.js\");\nvar client_2 = __webpack_require__(/*! ./client */ \"./node_modules/@fal-ai/client/src/client.js\");\nObject.defineProperty(exports, \"createFalClient\", ({ enumerable: true, get: function () { return client_2.createFalClient; } }));\nvar middleware_1 = __webpack_require__(/*! ./middleware */ \"./node_modules/@fal-ai/client/src/middleware.js\");\nObject.defineProperty(exports, \"withMiddleware\", ({ enumerable: true, get: function () { return middleware_1.withMiddleware; } }));\nObject.defineProperty(exports, \"withProxy\", ({ enumerable: true, get: function () { return middleware_1.withProxy; } }));\nvar response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nObject.defineProperty(exports, \"ApiError\", ({ enumerable: true, get: function () { return response_1.ApiError; } }));\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return response_1.ValidationError; } }));\nvar retry_1 = __webpack_require__(/*! ./retry */ \"./node_modules/@fal-ai/client/src/retry.js\");\nObject.defineProperty(exports, \"isRetryableError\", ({ enumerable: true, get: function () { return retry_1.isRetryableError; } }));\n__exportStar(__webpack_require__(/*! ./types/common */ \"./node_modules/@fal-ai/client/src/types/common.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\nObject.defineProperty(exports, \"parseEndpointId\", ({ enumerable: true, get: function () { return utils_1.parseEndpointId; } }));\n/**\n * Creates a singleton instance of the client. This is useful as a compatibility\n * layer for existing code that uses the clients version prior to 1.0.0.\n */\nexports.fal = (function createSingletonFalClient() {\n    let currentInstance = (0, client_1.createFalClient)();\n    return {\n        config(config) {\n            currentInstance = (0, client_1.createFalClient)(config);\n        },\n        get queue() {\n            return currentInstance.queue;\n        },\n        get realtime() {\n            return currentInstance.realtime;\n        },\n        get storage() {\n            return currentInstance.storage;\n        },\n        get streaming() {\n            return currentInstance.streaming;\n        },\n        run(id, options) {\n            return currentInstance.run(id, options);\n        },\n        subscribe(endpointId, options) {\n            return currentInstance.subscribe(endpointId, options);\n        },\n        stream(endpointId, options) {\n            return currentInstance.stream(endpointId, options);\n        },\n    };\n})();\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/index.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/middleware.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/middleware.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TARGET_URL_HEADER = void 0;\nexports.withMiddleware = withMiddleware;\nexports.withProxy = withProxy;\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nfunction withMiddleware(...middlewares) {\n    const isDefined = (middleware) => typeof middleware === \"function\";\n    return (config) => __awaiter(this, void 0, void 0, function* () {\n        let currentConfig = Object.assign({}, config);\n        for (const middleware of middlewares.filter(isDefined)) {\n            currentConfig = yield middleware(currentConfig);\n        }\n        return currentConfig;\n    });\n}\nexports.TARGET_URL_HEADER = \"x-fal-target-url\";\nfunction withProxy(config) {\n    const passthrough = (requestConfig) => Promise.resolve(requestConfig);\n    // when running on the server, we don't need to proxy the request\n    if (typeof window === \"undefined\") {\n        return passthrough;\n    }\n    // if x-fal-target-url is already set, we skip it\n    return (requestConfig) => requestConfig.headers && exports.TARGET_URL_HEADER in requestConfig\n        ? passthrough(requestConfig)\n        : Promise.resolve(Object.assign(Object.assign({}, requestConfig), { url: config.targetUrl, headers: Object.assign(Object.assign({}, (requestConfig.headers || {})), { [exports.TARGET_URL_HEADER]: requestConfig.url }) }));\n}\n//# sourceMappingURL=middleware.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/middleware.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/queue.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/queue.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createQueueClient = void 0;\nconst request_1 = __webpack_require__(/*! ./request */ \"./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst retry_1 = __webpack_require__(/*! ./retry */ \"./node_modules/@fal-ai/client/src/retry.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"./node_modules/@fal-ai/client/src/streaming.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\nconst DEFAULT_POLL_INTERVAL = 500;\n// Queue operations benefit from more aggressive retry policies\nconst QUEUE_RETRY_CONFIG = {\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 60000,\n    retryableStatusCodes: retry_1.DEFAULT_RETRYABLE_STATUS_CODES,\n};\n// Status checking can be retried more aggressively since it's read-only\nconst QUEUE_STATUS_RETRY_CONFIG = {\n    maxRetries: 5,\n    baseDelay: 1000,\n    maxDelay: 30000,\n    retryableStatusCodes: [...retry_1.DEFAULT_RETRYABLE_STATUS_CODES, 500],\n};\nconst createQueueClient = ({ config, storage, }) => {\n    const ref = {\n        submit(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { webhookUrl, priority, hint } = options, runOptions = __rest(options, [\"webhookUrl\", \"priority\", \"hint\"]);\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: \"queue\", query: webhookUrl ? { fal_webhook: webhookUrl } : undefined })),\n                    headers: Object.assign({ \"x-fal-queue-priority\": priority !== null && priority !== void 0 ? priority : \"normal\" }, (hint && { \"x-fal-runner-hint\": hint })),\n                    input: input,\n                    config,\n                    options: {\n                        signal: options.abortSignal,\n                        retry: QUEUE_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        status(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        query: { logs: logs ? \"1\" : \"0\" },\n                        path: `/requests/${requestId}/status`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                        retry: QUEUE_STATUS_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        streamStatus(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, connectionMode }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                const queryParams = {\n                    logs: logs ? \"1\" : \"0\",\n                };\n                const url = (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                    subdomain: \"queue\",\n                    path: `/requests/${requestId}/status/stream`,\n                    query: queryParams,\n                });\n                return new streaming_1.FalStream(endpointId, config, {\n                    url,\n                    method: \"get\",\n                    connectionMode,\n                    queryParams,\n                });\n            });\n        },\n        subscribeToStatus(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const requestId = options.requestId;\n                const timeout = options.timeout;\n                let timeoutId = undefined;\n                const handleCancelError = () => {\n                    // Ignore errors as the client will follow through with the timeout\n                    // regardless of the server response. In case cancelation fails, we\n                    // still want to reject the promise and consider the client call canceled.\n                };\n                if (options.mode === \"streaming\") {\n                    const status = yield ref.streamStatus(endpointId, {\n                        requestId,\n                        logs: options.logs,\n                        connectionMode: \"connectionMode\" in options\n                            ? options.connectionMode\n                            : undefined,\n                    });\n                    const logs = [];\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            status.abort();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            // TODO this error cannot bubble up to the user since it's thrown in\n                            // a closure in the global scope due to setTimeout behavior.\n                            // User will get a platform error instead. We should find a way to\n                            // make this behavior aligned with polling.\n                            throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);\n                        }, timeout);\n                    }\n                    status.on(\"data\", (data) => {\n                        if (options.onQueueUpdate) {\n                            // accumulate logs to match previous polling behavior\n                            if (\"logs\" in data &&\n                                Array.isArray(data.logs) &&\n                                data.logs.length > 0) {\n                                logs.push(...data.logs);\n                            }\n                            options.onQueueUpdate(\"logs\" in data ? Object.assign(Object.assign({}, data), { logs }) : data);\n                        }\n                    });\n                    const doneStatus = yield status.done();\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    return doneStatus;\n                }\n                // default to polling until status streaming is stable and faster\n                return new Promise((resolve, reject) => {\n                    var _a;\n                    let pollingTimeoutId;\n                    // type resolution isn't great in this case, so check for its presence\n                    // and and type so the typechecker behaves as expected\n                    const pollInterval = \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n                        ? ((_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL)\n                        : DEFAULT_POLL_INTERVAL;\n                    const clearScheduledTasks = () => {\n                        if (timeoutId) {\n                            clearTimeout(timeoutId);\n                        }\n                        if (pollingTimeoutId) {\n                            clearTimeout(pollingTimeoutId);\n                        }\n                    };\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            clearScheduledTasks();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));\n                        }, timeout);\n                    }\n                    const poll = () => __awaiter(this, void 0, void 0, function* () {\n                        var _a;\n                        try {\n                            const requestStatus = yield ref.status(endpointId, {\n                                requestId,\n                                logs: (_a = options.logs) !== null && _a !== void 0 ? _a : false,\n                                abortSignal: options.abortSignal,\n                            });\n                            if (options.onQueueUpdate) {\n                                options.onQueueUpdate(requestStatus);\n                            }\n                            if (requestStatus.status === \"COMPLETED\") {\n                                clearScheduledTasks();\n                                resolve(requestStatus);\n                                return;\n                            }\n                            pollingTimeoutId = setTimeout(poll, pollInterval);\n                        }\n                        catch (error) {\n                            clearScheduledTasks();\n                            reject(error);\n                        }\n                    });\n                    poll().catch(reject);\n                });\n            });\n        },\n        result(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}`,\n                    }),\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: abortSignal,\n                        retry: QUEUE_RETRY_CONFIG,\n                    },\n                });\n            });\n        },\n        cancel(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                yield (0, request_1.dispatchRequest)({\n                    method: \"put\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}/cancel`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                    },\n                });\n            });\n        },\n    };\n    return ref;\n};\nexports.createQueueClient = createQueueClient;\n//# sourceMappingURL=queue.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/queue.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/realtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/realtime.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRealtimeClient = createRealtimeClient;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.esm/index.mjs\");\nconst robot3_1 = __webpack_require__(/*! robot3 */ \"./node_modules/robot3/dist/machine.js\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"./node_modules/@fal-ai/client/src/auth.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\nconst initialState = () => ({\n    enqueuedMessage: undefined,\n});\nfunction hasToken(context) {\n    return context.token !== undefined;\n}\nfunction noToken(context) {\n    return !hasToken(context);\n}\nfunction enqueueMessage(context, event) {\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction closeConnection(context) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        context.websocket.close();\n    }\n    return Object.assign(Object.assign({}, context), { websocket: undefined });\n}\nfunction sendMessage(context, event) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        if (event.message instanceof Uint8Array) {\n            context.websocket.send(event.message);\n        }\n        else {\n            context.websocket.send((0, msgpack_1.encode)(event.message));\n        }\n        return Object.assign(Object.assign({}, context), { enqueuedMessage: undefined });\n    }\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction expireToken(context) {\n    return Object.assign(Object.assign({}, context), { token: undefined });\n}\nfunction setToken(context, event) {\n    return Object.assign(Object.assign({}, context), { token: event.token });\n}\nfunction connectionEstablished(context, event) {\n    return Object.assign(Object.assign({}, context), { websocket: event.websocket });\n}\n// State machine\nconst connectionStateMachine = (0, robot3_1.createMachine)(\"idle\", {\n    idle: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"expireToken\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    connecting: (0, robot3_1.state)((0, robot3_1.transition)(\"connecting\", \"connecting\"), (0, robot3_1.transition)(\"connected\", \"active\", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)(\"authRequired\", (0, robot3_1.guard)(noToken))),\n    authRequired: (0, robot3_1.state)((0, robot3_1.transition)(\"initiateAuth\", \"authInProgress\"), (0, robot3_1.transition)(\"send\", \"authRequired\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    authInProgress: (0, robot3_1.state)((0, robot3_1.transition)(\"authenticated\", \"connecting\", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"authInProgress\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    active: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"active\", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    failed: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"failed\"), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n}, initialState);\nfunction buildRealtimeUrl(app, { token, maxBuffering }) {\n    if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n        throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n    }\n    const queryParams = new URLSearchParams({\n        fal_jwt_token: token,\n    });\n    if (maxBuffering !== undefined) {\n        queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(app);\n    return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\nconst DEFAULT_THROTTLE_INTERVAL = 128;\nfunction isUnauthorizedError(message) {\n    // TODO we need better protocol definition with error codes\n    return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n    NORMAL_CLOSURE: 1000,\n    GOING_AWAY: 1001,\n};\nconst connectionCache = new Map();\nconst connectionCallbacks = new Map();\nfunction reuseInterpreter(key, throttleInterval, onChange) {\n    if (!connectionCache.has(key)) {\n        const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);\n        connectionCache.set(key, Object.assign(Object.assign({}, machine), { throttledSend: throttleInterval > 0\n                ? (0, utils_1.throttle)(machine.send, throttleInterval, true)\n                : machine.send }));\n    }\n    return connectionCache.get(key);\n}\nconst noop = () => {\n    /* No-op */\n};\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection = {\n    send: noop,\n    close: noop,\n};\nfunction isSuccessfulResult(data) {\n    return (data.status !== \"error\" &&\n        data.type !== \"x-fal-message\" &&\n        !isFalErrorResult(data));\n}\nfunction isFalErrorResult(data) {\n    return data.type === \"x-fal-error\";\n}\nfunction createRealtimeClient({ config, }) {\n    return {\n        connect(app, handler) {\n            const { \n            // if running on React in the server, set clientOnly to true by default\n            clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(), connectionKey = crypto.randomUUID(), maxBuffering, throttleInterval = DEFAULT_THROTTLE_INTERVAL, } = handler;\n            if (clientOnly && !(0, runtime_1.isBrowser)()) {\n                return NoOpConnection;\n            }\n            let previousState;\n            // Although the state machine is cached so we don't open multiple connections,\n            // we still need to update the callbacks so we can call the correct references\n            // when the state machine is reused. This is needed because the callbacks\n            // are passed as part of the handler object, which can be different across\n            // different calls to `connect`.\n            connectionCallbacks.set(connectionKey, {\n                onError: handler.onError,\n                onResult: handler.onResult,\n            });\n            const getCallbacks = () => connectionCallbacks.get(connectionKey);\n            const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({ context, machine, send }) => {\n                const { enqueuedMessage, token } = context;\n                if (machine.current === \"active\" && enqueuedMessage) {\n                    send({ type: \"send\", message: enqueuedMessage });\n                }\n                if (machine.current === \"authRequired\" &&\n                    token === undefined &&\n                    previousState !== machine.current) {\n                    send({ type: \"initiateAuth\" });\n                    (0, auth_1.getTemporaryAuthToken)(app, config)\n                        .then((token) => {\n                        send({ type: \"authenticated\", token });\n                        const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1000);\n                        setTimeout(() => {\n                            send({ type: \"expireToken\" });\n                        }, tokenExpirationTimeout);\n                    })\n                        .catch((error) => {\n                        send({ type: \"unauthorized\", error });\n                    });\n                }\n                if (machine.current === \"connecting\" &&\n                    previousState !== machine.current &&\n                    token !== undefined) {\n                    const ws = new WebSocket(buildRealtimeUrl(app, { token, maxBuffering }));\n                    ws.onopen = () => {\n                        send({ type: \"connected\", websocket: ws });\n                    };\n                    ws.onclose = (event) => {\n                        if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `Error closing the connection: ${event.reason}`,\n                                status: event.code,\n                            }));\n                        }\n                        send({ type: \"connectionClosed\", code: event.code });\n                    };\n                    ws.onerror = (event) => {\n                        // TODO specify error protocol for identified errors\n                        const { onError = noop } = getCallbacks();\n                        onError(new response_1.ApiError({ message: \"Unknown error\", status: 500 }));\n                    };\n                    ws.onmessage = (event) => {\n                        const { onResult } = getCallbacks();\n                        // Handle binary messages as msgpack messages\n                        if (event.data instanceof ArrayBuffer) {\n                            const result = (0, msgpack_1.decode)(new Uint8Array(event.data));\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Uint8Array) {\n                            const result = (0, msgpack_1.decode)(event.data);\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Blob) {\n                            event.data.arrayBuffer().then((buffer) => {\n                                const result = (0, msgpack_1.decode)(new Uint8Array(buffer));\n                                onResult(result);\n                            });\n                            return;\n                        }\n                        // Otherwise handle strings as plain JSON messages\n                        const data = JSON.parse(event.data);\n                        // Drop messages that are not related to the actual result.\n                        // In the future, we might want to handle other types of messages.\n                        // TODO: specify the fal ws protocol format\n                        if (isUnauthorizedError(data)) {\n                            send({\n                                type: \"unauthorized\",\n                                error: new Error(\"Unauthorized\"),\n                            });\n                            return;\n                        }\n                        if (isSuccessfulResult(data)) {\n                            onResult(data);\n                            return;\n                        }\n                        if (isFalErrorResult(data)) {\n                            if (data.error === \"TIMEOUT\") {\n                                // Timeout error messages just indicate that the connection hasn't\n                                // received an incoming message for a while. We don't need to\n                                // handle them as errors.\n                                return;\n                            }\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `${data.error}: ${data.reason}`,\n                                // TODO better error status code\n                                status: 400,\n                                body: data,\n                            }));\n                            return;\n                        }\n                    };\n                }\n                previousState = machine.current;\n            });\n            const send = (input) => {\n                // Use throttled send to avoid sending too many messages\n                stateMachine.throttledSend({\n                    type: \"send\",\n                    message: input,\n                });\n            };\n            const close = () => {\n                stateMachine.send({ type: \"close\" });\n            };\n            return {\n                send,\n                close,\n            };\n        },\n    };\n}\n//# sourceMappingURL=realtime.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/realtime.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/request.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/request.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dispatchRequest = dispatchRequest;\nexports.buildUrl = buildUrl;\nconst retry_1 = __webpack_require__(/*! ./retry */ \"./node_modules/@fal-ai/client/src/retry.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\nconst isCloudflareWorkers = typeof navigator !== \"undefined\" &&\n    (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === \"Cloudflare-Workers\";\nfunction dispatchRequest(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { targetUrl, input, config, options = {} } = params;\n        const { credentials: credentialsValue, requestMiddleware, responseHandler, fetch, } = config;\n        const retryOptions = Object.assign(Object.assign({}, config.retry), (options.retry || {}));\n        const executeRequest = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const userAgent = (0, runtime_1.isBrowser)() ? {} : { \"User-Agent\": (0, runtime_1.getUserAgent)() };\n            const credentials = typeof credentialsValue === \"function\"\n                ? credentialsValue()\n                : credentialsValue;\n            const { method, url, headers } = yield requestMiddleware({\n                method: ((_b = (_a = params.method) !== null && _a !== void 0 ? _a : options.method) !== null && _b !== void 0 ? _b : \"post\").toUpperCase(),\n                url: targetUrl,\n                headers: params.headers,\n            });\n            const authHeader = credentials\n                ? { Authorization: `Key ${credentials}` }\n                : {};\n            const requestHeaders = Object.assign(Object.assign(Object.assign(Object.assign({}, authHeader), { Accept: \"application/json\", \"Content-Type\": \"application/json\" }), userAgent), (headers !== null && headers !== void 0 ? headers : {}));\n            const { responseHandler: customResponseHandler, retry: _ } = options, requestInit = __rest(options, [\"responseHandler\", \"retry\"]);\n            const response = yield fetch(url, Object.assign(Object.assign(Object.assign(Object.assign({}, requestInit), { method, headers: Object.assign(Object.assign({}, requestHeaders), ((_c = requestInit.headers) !== null && _c !== void 0 ? _c : {})) }), (!isCloudflareWorkers && { mode: \"cors\" })), { signal: options.signal, body: method.toLowerCase() !== \"get\" && input\n                    ? JSON.stringify(input)\n                    : undefined }));\n            const handleResponse = customResponseHandler !== null && customResponseHandler !== void 0 ? customResponseHandler : responseHandler;\n            return yield handleResponse(response);\n        });\n        let lastError;\n        for (let attempt = 0; attempt <= retryOptions.maxRetries; attempt++) {\n            try {\n                return yield executeRequest();\n            }\n            catch (error) {\n                lastError = error;\n                const shouldNotRetry = attempt === retryOptions.maxRetries ||\n                    !(0, retry_1.isRetryableError)(error, retryOptions.retryableStatusCodes) ||\n                    ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted);\n                if (shouldNotRetry) {\n                    throw error;\n                }\n                const delay = (0, retry_1.calculateBackoffDelay)(attempt, retryOptions.baseDelay, retryOptions.maxDelay, retryOptions.backoffMultiplier, retryOptions.enableJitter);\n                yield (0, utils_1.sleep)(delay);\n            }\n        }\n        throw lastError;\n    });\n}\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nfunction buildUrl(id, options = {}) {\n    var _a, _b;\n    const method = ((_a = options.method) !== null && _a !== void 0 ? _a : \"post\").toLowerCase();\n    const path = ((_b = options.path) !== null && _b !== void 0 ? _b : \"\").replace(/^\\//, \"\").replace(/\\/{2,}/, \"/\");\n    const input = options.input;\n    const params = Object.assign(Object.assign({}, (options.query || {})), (method === \"get\" ? input : {}));\n    const queryParams = Object.keys(params).length > 0\n        ? `?${new URLSearchParams(params).toString()}`\n        : \"\";\n    // if a fal url is passed, just use it\n    if ((0, utils_1.isValidUrl)(id)) {\n        const url = id.endsWith(\"/\") ? id : `${id}/`;\n        return `${url}${path}${queryParams}`;\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(id);\n    const subdomain = options.subdomain ? `${options.subdomain}.` : \"\";\n    const url = `https://${subdomain}fal.run/${appId}/${path}`;\n    return `${url.replace(/\\/$/, \"\")}${queryParams}`;\n}\n//# sourceMappingURL=request.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/request.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/response.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/response.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidationError = exports.ApiError = void 0;\nexports.defaultResponseHandler = defaultResponseHandler;\nexports.resultResponseHandler = resultResponseHandler;\nconst REQUEST_ID_HEADER = \"x-fal-request-id\";\nclass ApiError extends Error {\n    constructor({ message, status, body }) {\n        super(message);\n        this.name = \"ApiError\";\n        this.status = status;\n        this.body = body;\n    }\n}\nexports.ApiError = ApiError;\nclass ValidationError extends ApiError {\n    constructor(args) {\n        super(args);\n        this.name = \"ValidationError\";\n    }\n    get fieldErrors() {\n        // NOTE: this is a hack to support both FastAPI/Pydantic errors\n        // and some custom 422 errors that might not be in the Pydantic format.\n        if (typeof this.body.detail === \"string\") {\n            return [\n                {\n                    loc: [\"body\"],\n                    msg: this.body.detail,\n                    type: \"value_error\",\n                },\n            ];\n        }\n        return this.body.detail || [];\n    }\n    getFieldErrors(field) {\n        return this.fieldErrors.filter((error) => error.loc[error.loc.length - 1] === field);\n    }\n}\nexports.ValidationError = ValidationError;\nfunction defaultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { status, statusText } = response;\n        const contentType = (_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"\";\n        if (!response.ok) {\n            if (contentType.includes(\"application/json\")) {\n                const body = yield response.json();\n                const ErrorType = status === 422 ? ValidationError : ApiError;\n                throw new ErrorType({\n                    message: body.message || statusText,\n                    status,\n                    body,\n                });\n            }\n            throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });\n        }\n        if (contentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        if (contentType.includes(\"text/html\")) {\n            return response.text();\n        }\n        if (contentType.includes(\"application/octet-stream\")) {\n            return response.arrayBuffer();\n        }\n        // TODO convert to either number or bool automatically\n        return response.text();\n    });\n}\nfunction resultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = yield defaultResponseHandler(response);\n        return {\n            data,\n            requestId: response.headers.get(REQUEST_ID_HEADER) || \"\",\n        };\n    });\n}\n//# sourceMappingURL=response.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/response.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/retry.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/retry.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_RETRY_OPTIONS = exports.DEFAULT_RETRYABLE_STATUS_CODES = void 0;\nexports.isRetryableError = isRetryableError;\nexports.calculateBackoffDelay = calculateBackoffDelay;\nexports.executeWithRetry = executeWithRetry;\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\n/**\n * Base retryable status codes for most requests\n */\nexports.DEFAULT_RETRYABLE_STATUS_CODES = [429, 502, 503, 504];\nexports.DEFAULT_RETRY_OPTIONS = {\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    retryableStatusCodes: exports.DEFAULT_RETRYABLE_STATUS_CODES,\n    enableJitter: true,\n};\n/**\n * Determines if an error is retryable based on the status code\n */\nfunction isRetryableError(error, retryableStatusCodes) {\n    return (error instanceof response_1.ApiError && retryableStatusCodes.includes(error.status));\n}\n/**\n * Calculates the backoff delay for a given attempt using exponential backoff\n */\nfunction calculateBackoffDelay(attempt, baseDelay, maxDelay, backoffMultiplier, enableJitter) {\n    const exponentialDelay = Math.min(baseDelay * Math.pow(backoffMultiplier, attempt), maxDelay);\n    if (enableJitter) {\n        // Add 25% jitter to prevent thundering herd\n        const jitter = 0.25 * exponentialDelay * (Math.random() * 2 - 1);\n        return Math.max(0, exponentialDelay + jitter);\n    }\n    return exponentialDelay;\n}\n/**\n * Executes an operation with retry logic and returns both result and metrics\n */\nfunction executeWithRetry(operation, options, onRetry) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const metrics = {\n            totalAttempts: 0,\n            totalDelay: 0,\n        };\n        let lastError;\n        for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n            metrics.totalAttempts++;\n            try {\n                const result = yield operation();\n                return { result, metrics };\n            }\n            catch (error) {\n                lastError = error;\n                metrics.lastError = error;\n                if (attempt === options.maxRetries ||\n                    !isRetryableError(error, options.retryableStatusCodes)) {\n                    throw error;\n                }\n                const delay = calculateBackoffDelay(attempt, options.baseDelay, options.maxDelay, options.backoffMultiplier, options.enableJitter);\n                metrics.totalDelay += delay;\n                if (onRetry) {\n                    onRetry(attempt + 1, error, delay);\n                }\n                yield (0, utils_1.sleep)(delay);\n            }\n        }\n        throw lastError;\n    });\n}\n//# sourceMappingURL=retry.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/retry.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/runtime.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/runtime.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\n/* eslint-disable @typescript-eslint/no-var-requires */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBrowser = isBrowser;\nexports.getUserAgent = getUserAgent;\nfunction isBrowser() {\n    return (typeof window !== \"undefined\" && typeof window.document !== \"undefined\");\n}\nlet memoizedUserAgent = null;\nfunction getUserAgent() {\n    if (memoizedUserAgent !== null) {\n        return memoizedUserAgent;\n    }\n    const packageInfo = __webpack_require__(/*! ../package.json */ \"./node_modules/@fal-ai/client/package.json\");\n    memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;\n    return memoizedUserAgent;\n}\n//# sourceMappingURL=runtime.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/runtime.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/storage.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/storage.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStorageClient = createStorageClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@fal-ai/client/src/utils.js\");\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType) {\n    var _a;\n    const [_, fileType] = contentType.split(\"/\");\n    return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : \"bin\";\n}\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            // NOTE: We want to test V3 without making it the default at the API level\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateMultipartUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\nfunction partUploadRetries(uploadUrl_1, chunk_1, config_2) {\n    return __awaiter(this, arguments, void 0, function* (uploadUrl, chunk, config, tries = 3) {\n        if (tries === 0) {\n            throw new Error(\"Part upload failed, retries exhausted\");\n        }\n        const { fetch, responseHandler } = config;\n        try {\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: chunk,\n            });\n            return (yield responseHandler(response));\n        }\n        catch (error) {\n            return yield partUploadRetries(uploadUrl, chunk, config, tries - 1);\n        }\n    });\n}\nfunction multipartUpload(file, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { fetch, responseHandler } = config;\n        const contentType = file.type || \"application/octet-stream\";\n        const { upload_url: uploadUrl, file_url: url } = yield initiateMultipartUpload(file, config, contentType);\n        // Break the file into 10MB chunks\n        const chunkSize = 10 * 1024 * 1024;\n        const chunks = Math.ceil(file.size / chunkSize);\n        const parsedUrl = new URL(uploadUrl);\n        const responses = [];\n        for (let i = 0; i < chunks; i++) {\n            const start = i * chunkSize;\n            const end = Math.min(start + chunkSize, file.size);\n            const chunk = file.slice(start, end);\n            const partNumber = i + 1;\n            // {uploadUrl}/{part_number}?uploadUrlParams=...\n            const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n            responses.push(yield partUploadRetries(partUploadUrl, chunk, config));\n        }\n        // Complete the upload\n        const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n        const response = yield fetch(completeUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                parts: responses.map((mpart) => ({\n                    partNumber: mpart.partNumber,\n                    etag: mpart.etag,\n                })),\n            }),\n        });\n        yield responseHandler(response);\n        return url;\n    });\n}\nfunction createStorageClient({ config, }) {\n    const ref = {\n        upload: (file) => __awaiter(this, void 0, void 0, function* () {\n            // Check for 90+ MB file size to do multipart upload\n            if (file.size > 90 * 1024 * 1024) {\n                return yield multipartUpload(file, config);\n            }\n            const contentType = file.type || \"application/octet-stream\";\n            const { fetch, responseHandler } = config;\n            const { upload_url: uploadUrl, file_url: url } = yield initiateUpload(file, config, contentType);\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: file,\n                headers: {\n                    \"Content-Type\": file.type || \"application/octet-stream\",\n                },\n            });\n            yield responseHandler(response);\n            return url;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        transformInput: (input) => __awaiter(this, void 0, void 0, function* () {\n            if (Array.isArray(input)) {\n                return Promise.all(input.map((item) => ref.transformInput(item)));\n            }\n            else if (input instanceof Blob) {\n                return yield ref.upload(input);\n            }\n            else if ((0, utils_1.isPlainObject)(input)) {\n                const inputObject = input;\n                const promises = Object.entries(inputObject).map((_a) => __awaiter(this, [_a], void 0, function* ([key, value]) {\n                    return [key, yield ref.transformInput(value)];\n                }));\n                const results = yield Promise.all(promises);\n                return Object.fromEntries(results);\n            }\n            // Return the input as is if it's neither an object nor a file/blob/data URI\n            return input;\n        }),\n    };\n    return ref;\n}\n//# sourceMappingURL=storage.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/storage.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/streaming.js":
/*!******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/streaming.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FalStream = void 0;\nexports.createStreamingClient = createStreamingClient;\nconst eventsource_parser_1 = __webpack_require__(/*! eventsource-parser */ \"./node_modules/eventsource-parser/dist/index.cjs\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"./node_modules/@fal-ai/client/src/auth.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"./node_modules/@fal-ai/client/src/response.js\");\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n/**\n * The class representing a streaming response. With t\n */\nclass FalStream {\n    constructor(endpointId, config, options) {\n        var _a;\n        // support for event listeners\n        this.listeners = new Map();\n        this.buffer = [];\n        // local state\n        this.currentData = undefined;\n        this.lastEventTimestamp = 0;\n        this.streamClosed = false;\n        this._requestId = null;\n        this.abortController = new AbortController();\n        this.start = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const { endpointId, options } = this;\n            const { input, method = \"post\", connectionMode = \"server\" } = options;\n            try {\n                if (connectionMode === \"client\") {\n                    // if we are in the browser, we need to get a temporary token\n                    // to authenticate the request\n                    const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId, this.config);\n                    const { fetch } = this.config;\n                    const parsedUrl = new URL(this.url);\n                    parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n                    const response = yield fetch(parsedUrl.toString(), {\n                        method: method.toUpperCase(),\n                        headers: {\n                            accept: (_a = options.accept) !== null && _a !== void 0 ? _a : CONTENT_TYPE_EVENT_STREAM,\n                            \"content-type\": \"application/json\",\n                        },\n                        body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n                        signal: this.abortController.signal,\n                    });\n                    this._requestId = response.headers.get(\"x-fal-request-id\");\n                    return yield this.handleResponse(response);\n                }\n                return yield (0, request_1.dispatchRequest)({\n                    method: method.toUpperCase(),\n                    targetUrl: this.url,\n                    input,\n                    config: this.config,\n                    options: {\n                        headers: {\n                            accept: (_b = options.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM,\n                        },\n                        responseHandler: (response) => __awaiter(this, void 0, void 0, function* () {\n                            this._requestId = response.headers.get(\"x-fal-request-id\");\n                            return yield this.handleResponse(response);\n                        }),\n                        signal: this.abortController.signal,\n                    },\n                });\n            }\n            catch (error) {\n                this.handleError(error);\n            }\n        });\n        this.handleResponse = (response) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!response.ok) {\n                try {\n                    // we know the response failed, call the response handler\n                    // so the exception gets converted to ApiError correctly\n                    yield (0, response_1.defaultResponseHandler)(response);\n                }\n                catch (error) {\n                    this.emit(\"error\", error);\n                }\n                return;\n            }\n            const body = response.body;\n            if (!body) {\n                this.emit(\"error\", new response_1.ApiError({\n                    message: \"Response body is empty.\",\n                    status: 400,\n                    body: undefined,\n                }));\n                return;\n            }\n            const isEventStream = ((_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\").startsWith(CONTENT_TYPE_EVENT_STREAM);\n            // any response that is not a text/event-stream will be handled as a binary stream\n            if (!isEventStream) {\n                const reader = body.getReader();\n                const emitRawChunk = () => {\n                    reader.read().then(({ done, value }) => {\n                        if (done) {\n                            this.emit(\"done\", this.currentData);\n                            return;\n                        }\n                        this.currentData = value;\n                        this.emit(\"data\", value);\n                        emitRawChunk();\n                    });\n                };\n                emitRawChunk();\n                return;\n            }\n            const decoder = new TextDecoder(\"utf-8\");\n            const reader = response.body.getReader();\n            const parser = (0, eventsource_parser_1.createParser)((event) => {\n                if (event.type === \"event\") {\n                    const data = event.data;\n                    try {\n                        const parsedData = JSON.parse(data);\n                        this.buffer.push(parsedData);\n                        this.currentData = parsedData;\n                        this.emit(\"data\", parsedData);\n                        // also emit 'message'for backwards compatibility\n                        this.emit(\"message\", parsedData);\n                    }\n                    catch (e) {\n                        this.emit(\"error\", e);\n                    }\n                }\n            });\n            const timeout = (_b = this.options.timeout) !== null && _b !== void 0 ? _b : EVENT_STREAM_TIMEOUT;\n            const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {\n                const { value, done } = yield reader.read();\n                this.lastEventTimestamp = Date.now();\n                parser.feed(decoder.decode(value));\n                if (Date.now() - this.lastEventTimestamp > timeout) {\n                    this.emit(\"error\", new response_1.ApiError({\n                        message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n                        status: 408,\n                    }));\n                }\n                if (!done) {\n                    readPartialResponse().catch(this.handleError);\n                }\n                else {\n                    this.emit(\"done\", this.currentData);\n                }\n            });\n            readPartialResponse().catch(this.handleError);\n            return;\n        });\n        this.handleError = (error) => {\n            var _a;\n            // In case AbortError is thrown but the signal is marked as aborted\n            // it means the user called abort() and we should not emit an error\n            // as it's expected behavior\n            // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n            if (error.name === \"AbortError\" || this.signal.aborted) {\n                return;\n            }\n            const apiError = error instanceof response_1.ApiError\n                ? error\n                : new response_1.ApiError({\n                    message: (_a = error.message) !== null && _a !== void 0 ? _a : \"An unknown error occurred\",\n                    status: 500,\n                });\n            this.emit(\"error\", apiError);\n            return;\n        };\n        this.on = (type, listener) => {\n            var _a;\n            if (!this.listeners.has(type)) {\n                this.listeners.set(type, []);\n            }\n            (_a = this.listeners.get(type)) === null || _a === void 0 ? void 0 : _a.push(listener);\n        };\n        this.emit = (type, event) => {\n            const listeners = this.listeners.get(type) || [];\n            for (const listener of listeners) {\n                listener(event);\n            }\n        };\n        /**\n         * Gets a reference to the `Promise` that indicates whether the streaming\n         * is done or not. Developers should always call this in their apps to ensure\n         * the request is over.\n         *\n         * An alternative to this, is to use `on('done')` in case your application\n         * architecture works best with event listeners.\n         *\n         * @returns the promise that resolves when the request is done.\n         */\n        this.done = () => __awaiter(this, void 0, void 0, function* () { return this.donePromise; });\n        /**\n         * Aborts the streaming request.\n         *\n         * **Note:** This method is noop in case the request is already done.\n         *\n         * @param reason optional cause for aborting the request.\n         */\n        this.abort = (reason) => {\n            if (!this.streamClosed) {\n                this.abortController.abort(reason);\n            }\n        };\n        this.endpointId = endpointId;\n        this.config = config;\n        this.url =\n            (_a = options.url) !== null && _a !== void 0 ? _a : (0, request_1.buildUrl)(endpointId, {\n                path: \"/stream\",\n                query: options.queryParams,\n            });\n        this.options = options;\n        this.donePromise = new Promise((resolve, reject) => {\n            if (this.streamClosed) {\n                reject(new response_1.ApiError({\n                    message: \"Streaming connection is already closed.\",\n                    status: 400,\n                    body: undefined,\n                }));\n            }\n            this.signal.addEventListener(\"abort\", () => {\n                var _a;\n                resolve((_a = this.currentData) !== null && _a !== void 0 ? _a : {});\n            });\n            this.on(\"done\", (data) => {\n                this.streamClosed = true;\n                resolve(data);\n            });\n            this.on(\"error\", (error) => {\n                this.streamClosed = true;\n                reject(error);\n            });\n        });\n        // if a abort signal was passed, sync it with the internal one\n        if (options.signal) {\n            options.signal.addEventListener(\"abort\", () => {\n                this.abortController.abort();\n            });\n        }\n        // start the streaming request\n        this.start().catch(this.handleError);\n    }\n    [Symbol.asyncIterator]() {\n        return __asyncGenerator(this, arguments, function* _a() {\n            let running = true;\n            const stopAsyncIterator = () => (running = false);\n            this.on(\"error\", stopAsyncIterator);\n            this.on(\"done\", stopAsyncIterator);\n            while (running || this.buffer.length > 0) {\n                const data = this.buffer.shift();\n                if (data) {\n                    yield yield __await(data);\n                }\n                // the short timeout ensures the while loop doesn't block other\n                // frames getting executed concurrently\n                yield __await(new Promise((resolve) => setTimeout(resolve, 16)));\n            }\n        });\n    }\n    /**\n     * Gets the `AbortSignal` instance that can be used to listen for abort events.\n     *\n     * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n     * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n     *\n     * @returns the `AbortSignal` instance.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n     */\n    get signal() {\n        return this.abortController.signal;\n    }\n    /**\n     * Gets the request id of the streaming request.\n     *\n     * @returns the request id.\n     */\n    get requestId() {\n        return this._requestId;\n    }\n}\nexports.FalStream = FalStream;\nfunction createStreamingClient({ config, storage, }) {\n    return {\n        stream(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return new FalStream(endpointId, config, Object.assign(Object.assign({}, options), { input: input }));\n            });\n        },\n    };\n}\n//# sourceMappingURL=streaming.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/streaming.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/types/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/types/common.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isQueueStatus = isQueueStatus;\nexports.isCompletedQueueStatus = isCompletedQueueStatus;\nfunction isQueueStatus(obj) {\n    return obj && obj.status && obj.response_url;\n}\nfunction isCompletedQueueStatus(obj) {\n    return isQueueStatus(obj) && obj.status === \"COMPLETED\";\n}\n//# sourceMappingURL=common.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/types/common.js?\n}");

/***/ }),

/***/ "./node_modules/@fal-ai/client/src/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/utils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureEndpointIdFormat = ensureEndpointIdFormat;\nexports.parseEndpointId = parseEndpointId;\nexports.isValidUrl = isValidUrl;\nexports.throttle = throttle;\nexports.isReact = isReact;\nexports.isPlainObject = isPlainObject;\nexports.sleep = sleep;\nfunction ensureEndpointIdFormat(id) {\n    const parts = id.split(\"/\");\n    if (parts.length > 1) {\n        return id;\n    }\n    const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];\n    if (appOwner && appId) {\n        return `${appOwner}/${appId}`;\n    }\n    throw new Error(`Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`);\n}\nconst ENDPOINT_NAMESPACES = [\"workflows\", \"comfy\"];\nfunction parseEndpointId(id) {\n    const normalizedId = ensureEndpointIdFormat(id);\n    const parts = normalizedId.split(\"/\");\n    if (ENDPOINT_NAMESPACES.includes(parts[0])) {\n        return {\n            owner: parts[1],\n            alias: parts[2],\n            path: parts.slice(3).join(\"/\") || undefined,\n            namespace: parts[0],\n        };\n    }\n    return {\n        owner: parts[0],\n        alias: parts[1],\n        path: parts.slice(2).join(\"/\") || undefined,\n    };\n}\nfunction isValidUrl(url) {\n    try {\n        const { host } = new URL(url);\n        return /(fal\\.(ai|run))$/.test(host);\n    }\n    catch (_) {\n        return false;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(func, limit, leading = false) {\n    let lastFunc;\n    let lastRan;\n    return (...args) => {\n        if (!lastRan && leading) {\n            func(...args);\n            lastRan = Date.now();\n        }\n        else {\n            if (lastFunc) {\n                clearTimeout(lastFunc);\n            }\n            lastFunc = setTimeout(() => {\n                if (Date.now() - lastRan >= limit) {\n                    func(...args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    };\n}\nlet isRunningInReact;\n/**\n * Not really the most optimal way to detect if we're running in React,\n * but the idea here is that we can support multiple rendering engines\n * (starting with React), with all their peculiarities, without having\n * to add a dependency or creating custom integrations (e.g. custom hooks).\n *\n * Yes, a bit of magic to make things works out-of-the-box.\n * @returns `true` if running in React, `false` otherwise.\n */\nfunction isReact() {\n    if (isRunningInReact === undefined) {\n        const stack = new Error().stack;\n        isRunningInReact =\n            !!stack &&\n                (stack.includes(\"node_modules/react-dom/\") ||\n                    stack.includes(\"node_modules/next/\"));\n    }\n    return isRunningInReact;\n}\n/**\n * Check if a value is a plain object.\n * @param value - The value to check.\n * @returns `true` if the value is a plain object, `false` otherwise.\n */\nfunction isPlainObject(value) {\n    return !!value && Object.getPrototypeOf(value) === Object.prototype;\n}\n/**\n * Utility function to sleep for a given number of milliseconds\n */\nfunction sleep(ms) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    });\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@fal-ai/client/src/utils.js?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nclass CachedKeyDecoder {\n    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n        this.hit = 0;\n        this.miss = 0;\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (let i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    canBeCached(byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    }\n    find(bytes, inputOffset, byteLength) {\n        const records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (const record of records) {\n            const recordBytes = record.bytes;\n            for (let j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    }\n    store(bytes, value) {\n        const records = this.caches[bytes.length - 1];\n        const record = { bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    }\n    decode(bytes, inputOffset, byteLength) {\n        const cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        const str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    }\n}\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nclass DecodeError extends Error {\n    constructor(message) {\n        super(message);\n        // fix the prototype chain in a cross-platform way\n        const proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(this, proto);\n        Object.defineProperty(this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n    }\n}\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs\");\n\n\n\n\n\n\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\nconst mapKeyConverter = (key) => {\n    if (typeof key === \"string\" || typeof key === \"number\") {\n        return key;\n    }\n    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\nclass StackPool {\n    constructor() {\n        this.stack = [];\n        this.stackHeadPosition = -1;\n    }\n    get length() {\n        return this.stackHeadPosition + 1;\n    }\n    top() {\n        return this.stack[this.stackHeadPosition];\n    }\n    pushArrayState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_ARRAY;\n        state.position = 0;\n        state.size = size;\n        state.array = new Array(size);\n    }\n    pushMapState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_MAP_KEY;\n        state.readCount = 0;\n        state.size = size;\n        state.map = {};\n    }\n    getUninitializedStateFromPool() {\n        this.stackHeadPosition++;\n        if (this.stackHeadPosition === this.stack.length) {\n            const partialState = {\n                type: undefined,\n                size: 0,\n                array: undefined,\n                position: 0,\n                readCount: 0,\n                map: undefined,\n                key: null,\n            };\n            this.stack.push(partialState);\n        }\n        return this.stack[this.stackHeadPosition];\n    }\n    release(state) {\n        const topStackState = this.stack[this.stackHeadPosition];\n        if (topStackState !== state) {\n            throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n        }\n        if (state.type === STATE_ARRAY) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.array = undefined;\n            partialState.position = 0;\n            partialState.type = undefined;\n        }\n        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.map = undefined;\n            partialState.readCount = 0;\n            partialState.type = undefined;\n        }\n        this.stackHeadPosition--;\n    }\n    reset() {\n        this.stack.length = 0;\n        this.stackHeadPosition = -1;\n    }\n}\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nconst MORE_DATA = new RangeError(\"Insufficient data\");\nconst sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__.CachedKeyDecoder();\nclass Decoder {\n    constructor(options) {\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = new StackPool();\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.rawStrings = options?.rawStrings ?? false;\n        this.maxStrLength = options?.maxStrLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxBinLength = options?.maxBinLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxArrayLength = options?.maxArrayLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxMapLength = options?.maxMapLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxExtLength = options?.maxExtLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n    }\n    clone() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Decoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            rawStrings: this.rawStrings,\n            maxStrLength: this.maxStrLength,\n            maxBinLength: this.maxBinLength,\n            maxArrayLength: this.maxArrayLength,\n            maxMapLength: this.maxMapLength,\n            maxExtLength: this.maxExtLength,\n            keyDecoder: this.keyDecoder,\n        });\n    }\n    reinitializeState() {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.reset();\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    }\n    setBuffer(buffer) {\n        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);\n        this.bytes = bytes;\n        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        this.pos = 0;\n    }\n    appendBuffer(buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            const remainingData = this.bytes.subarray(this.pos);\n            const newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            const newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    }\n    hasRemaining(size) {\n        return this.view.byteLength - this.pos >= size;\n    }\n    createExtraByteError(posToShow) {\n        const { view, pos } = this;\n        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n    }\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    decode(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decode(buffer);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            const object = this.doDecodeSync();\n            if (this.hasRemaining(1)) {\n                throw this.createExtraByteError(this.pos);\n            }\n            return object;\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    *decodeMulti(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMulti(buffer);\n            return;\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            while (this.hasRemaining(1)) {\n                yield this.doDecodeSync();\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    async decodeAsync(stream) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decodeAsync(stream);\n        }\n        try {\n            this.entered = true;\n            let decoded = false;\n            let object;\n            for await (const buffer of stream) {\n                if (decoded) {\n                    this.entered = false;\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                try {\n                    object = this.doDecodeSync();\n                    decoded = true;\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n            if (decoded) {\n                if (this.hasRemaining(1)) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                return object;\n            }\n            const { headByte, pos, totalPos } = this;\n            throw new RangeError(`Insufficient data in parsing ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    decodeArrayStream(stream) {\n        return this.decodeMultiAsync(stream, true);\n    }\n    decodeStream(stream) {\n        return this.decodeMultiAsync(stream, false);\n    }\n    async *decodeMultiAsync(stream, isArray) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMultiAsync(stream, isArray);\n            return;\n        }\n        try {\n            this.entered = true;\n            let isArrayHeaderRequired = isArray;\n            let arrayItemsLeft = -1;\n            for await (const buffer of stream) {\n                if (isArray && arrayItemsLeft === 0) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                if (isArrayHeaderRequired) {\n                    arrayItemsLeft = this.readArraySize();\n                    isArrayHeaderRequired = false;\n                    this.complete();\n                }\n                try {\n                    while (true) {\n                        yield this.doDecodeSync();\n                        if (--arrayItemsLeft === 0) {\n                            break;\n                        }\n                    }\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doDecodeSync() {\n        DECODE: while (true) {\n            const headByte = this.readHeadByte();\n            let object;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    const size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    const size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    const byteLength = headByte - 0xa0;\n                    object = this.decodeString(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                const byteLength = this.lookU8();\n                object = this.decodeString(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                const byteLength = this.lookU16();\n                object = this.decodeString(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                const byteLength = this.lookU32();\n                object = this.decodeString(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                const size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                const size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                const size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                const size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                const size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                const size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Unrecognized type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__.prettyByte)(headByte)}`);\n            }\n            this.complete();\n            const stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                const state = stack.top();\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        object = state.array;\n                        stack.release(state);\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = this.mapKeyConverter(object);\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        object = state.map;\n                        stack.release(state);\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    }\n    readHeadByte() {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    }\n    complete() {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    }\n    readArraySize() {\n        const headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Unrecognized array type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__.prettyByte)(headByte)}`);\n                }\n            }\n        }\n    }\n    pushMapState(size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n        }\n        this.stack.pushMapState(size);\n    }\n    pushArrayState(size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n        }\n        this.stack.pushArrayState(size);\n    }\n    decodeString(byteLength, headerOffset) {\n        if (!this.rawStrings || this.stateIsMapKey()) {\n            return this.decodeUtf8String(byteLength, headerOffset);\n        }\n        return this.decodeBinary(byteLength, headerOffset);\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeUtf8String(byteLength, headerOffset) {\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headerOffset;\n        let object;\n        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__.utf8Decode)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    }\n    stateIsMapKey() {\n        if (this.stack.length > 0) {\n            const state = this.stack.top();\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeBinary(byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headOffset;\n        const object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    }\n    decodeExtension(size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n        }\n        const extType = this.view.getInt8(this.pos + headOffset);\n        const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    }\n    lookU8() {\n        return this.view.getUint8(this.pos);\n    }\n    lookU16() {\n        return this.view.getUint16(this.pos);\n    }\n    lookU32() {\n        return this.view.getUint32(this.pos);\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readI8() {\n        const value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readI16() {\n        const value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readI32() {\n        const value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readU64() {\n        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64() {\n        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readU64AsBigInt() {\n        const value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64AsBigInt() {\n        const value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readF32() {\n        const value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readF64() {\n        const value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n}\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs\");\n\n\n\n\nconst DEFAULT_MAX_DEPTH = 100;\nconst DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nclass Encoder {\n    constructor(options) {\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = options?.sortKeys ?? false;\n        this.forceFloat32 = options?.forceFloat32 ?? false;\n        this.ignoreUndefined = options?.ignoreUndefined ?? false;\n        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    clone() {\n        // Because of slightly special argument `context`,\n        // type assertion is needed.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Encoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            maxDepth: this.maxDepth,\n            initialBufferSize: this.initialBufferSize,\n            sortKeys: this.sortKeys,\n            forceFloat32: this.forceFloat32,\n            ignoreUndefined: this.ignoreUndefined,\n            forceIntegerToFloat: this.forceIntegerToFloat,\n        });\n    }\n    reinitializeState() {\n        this.pos = 0;\n    }\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    encodeSharedRef(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encodeSharedRef(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.subarray(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    encode(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encode(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.slice(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doEncode(object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(`Too deep objects in depth ${depth}`);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    }\n    ensureBufferSizeToWrite(sizeToWrite) {\n        const requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    }\n    resizeBuffer(newSize) {\n        const newBuffer = new ArrayBuffer(newSize);\n        const newBytes = new Uint8Array(newBuffer);\n        const newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    }\n    encodeNil() {\n        this.writeU8(0xc0);\n    }\n    encodeBoolean(object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    }\n    encodeNumber(object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    }\n    encodeNumberAsFloat(object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    }\n    encodeBigInt64(object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    }\n    writeStringHeader(byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n        }\n    }\n    encodeString(object) {\n        const maxHeaderSize = 1 + 4;\n        const byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8Count)(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8Encode)(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    }\n    encodeObject(object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        const ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n        }\n    }\n    encodeBinary(object) {\n        const size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large binary: ${size}`);\n        }\n        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    }\n    encodeArray(object, depth) {\n        const size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large array: ${size}`);\n        }\n        for (const item of object) {\n            this.doEncode(item, depth + 1);\n        }\n    }\n    countWithoutUndefined(object, keys) {\n        let count = 0;\n        for (const key of keys) {\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    }\n    encodeMap(object, depth) {\n        const keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large map object: ${size}`);\n        }\n        for (const key of keys) {\n            const value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    }\n    encodeExtension(ext) {\n        if (typeof ext.data === \"function\") {\n            const data = ext.data(this.pos + 6);\n            const size = data.length;\n            if (size >= 0x100000000) {\n                throw new Error(`Too large extension object: ${size}`);\n            }\n            this.writeU8(0xc9);\n            this.writeU32(size);\n            this.writeI8(ext.type);\n            this.writeU8a(data);\n            return;\n        }\n        const size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large extension object: ${size}`);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    }\n    writeU8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    }\n    writeU8a(values) {\n        const size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    }\n    writeI8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    }\n    writeU16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    }\n    writeI16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    }\n    writeU32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    }\n    writeI32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    }\n    writeU64(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeI64(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeBigUint64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    }\n    writeBigInt64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    }\n}\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nclass ExtData {\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n}\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nclass ExtensionCodec {\n    constructor() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__.timestampExtension);\n    }\n    register({ type, encode, decode, }) {\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            const index = -1 - type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    }\n    tryToEncode(object, context) {\n        // built-in extensions\n        for (let i = 0; i < this.builtInEncoders.length; i++) {\n            const encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (let i = 0; i < this.encoders.length; i++) {\n            const encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    }\n    decode(data, type, context) {\n        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtData(type, data);\n        }\n    }\n}\nExtensionCodec.defaultCodec = new ExtensionCodec();\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/decode.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/decode.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeMulti: () => (/* binding */ decodeMulti)\n/* harmony export */ });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs\");\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decode(buffer, options) {\n    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decodeMulti(buffer, options) {\n    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/decode.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeArrayStream: () => (/* binding */ decodeArrayStream),\n/* harmony export */   decodeAsync: () => (/* binding */ decodeAsync),\n/* harmony export */   decodeMultiStream: () => (/* binding */ decodeMultiStream)\n/* harmony export */ });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs\");\n/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/stream.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs\");\n\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nasync function decodeAsync(streamLike, options) {\n    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__.ensureAsyncIterable)(streamLike);\n    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);\n    return decoder.decodeAsync(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decodeArrayStream(streamLike, options) {\n    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__.ensureAsyncIterable)(streamLike);\n    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);\n    return decoder.decodeArrayStream(stream);\n}\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decodeMultiStream(streamLike, options) {\n    const stream = (0,_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__.ensureAsyncIterable)(streamLike);\n    const decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options);\n    return decoder.decodeStream(stream);\n}\n//# sourceMappingURL=decodeAsync.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/encode.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/encode.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs\");\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    const encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/encode.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* reexport safe */ _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__.DecodeError),\n/* harmony export */   Decoder: () => (/* reexport safe */ _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__.Decoder),\n/* harmony export */   EXT_TIMESTAMP: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.EXT_TIMESTAMP),\n/* harmony export */   Encoder: () => (/* reexport safe */ _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__.Encoder),\n/* harmony export */   ExtData: () => (/* reexport safe */ _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtData),\n/* harmony export */   ExtensionCodec: () => (/* reexport safe */ _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionCodec),\n/* harmony export */   decode: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   decodeArrayStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeArrayStream),\n/* harmony export */   decodeAsync: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeAsync),\n/* harmony export */   decodeMulti: () => (/* reexport safe */ _decode_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeMulti),\n/* harmony export */   decodeMultiStream: () => (/* reexport safe */ _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeMultiStream),\n/* harmony export */   decodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.decodeTimestampToTimeSpec),\n/* harmony export */   encode: () => (/* reexport safe */ _encode_mjs__WEBPACK_IMPORTED_MODULE_0__.encode),\n/* harmony export */   encodeDateToTimeSpec: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* reexport safe */ _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__.encodeTimestampExtension)\n/* harmony export */ });\n/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/encode.mjs\");\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/decode.mjs\");\n/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decodeAsync.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/decodeAsync.mjs\");\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs\");\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs\");\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs\");\n// Main Functions:\n\n\n\n\n\n\n\n\n\n\n\n\n// Utilities for Extension Types:\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/index.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nconst EXT_TIMESTAMP = -1;\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp({ sec, nsec }) {\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            const rv = new Uint8Array(4);\n            const view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            const secHigh = sec / 0x100000000;\n            const secLow = sec & 0xffffffff;\n            const rv = new Uint8Array(8);\n            const view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        const rv = new Uint8Array(12);\n        const view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    const msec = date.getTime();\n    const sec = Math.floor(msec / 1e3);\n    const nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    const nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        const timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            const sec = view.getUint32(0);\n            const nsec = 0;\n            return { sec, nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            const nsec30AndSecHigh2 = view.getUint32(0);\n            const secLow32 = view.getUint32(4);\n            const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            const nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec, nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            const sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__.getInt64)(view, 4);\n            const nsec = view.getUint32(0);\n            return { sec, nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    const timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nconst timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nconst UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    const high = value / 4294967296;\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    const high = Math.floor(value / 4294967296);\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    const high = view.getInt32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    const high = view.getUint32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asyncIterableFromStream: () => (/* binding */ asyncIterableFromStream),\n/* harmony export */   ensureAsyncIterable: () => (/* binding */ ensureAsyncIterable),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)\n/* harmony export */ });\n// utility for whatwg streams\nfunction isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nasync function* asyncIterableFromStream(stream) {\n    const reader = stream.getReader();\n    try {\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n                return;\n            }\n            yield value;\n        }\n    }\n    finally {\n        reader.releaseLock();\n    }\n}\nfunction ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/utils/stream.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction isArrayBufferLike(buffer) {\n    return (buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer));\n}\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (isArrayBufferLike(buffer)) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs?\n}");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\nfunction utf8Count(str) {\n    const strLength = str.length;\n    let byteLength = 0;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    const strLength = str.length;\n    let offset = outputOffset;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nconst sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\nfunction utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nfunction utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nconst CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    let offset = inputOffset;\n    const end = offset + byteLength;\n    const units = [];\n    let result = \"\";\n    while (offset < end) {\n        const byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            const byte4 = bytes[offset++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode(...units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode(...units);\n    }\n    return result;\n}\nconst sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nfunction utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs?\n}");

/***/ }),

/***/ "./node_modules/eventsource-parser/dist/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/eventsource-parser/dist/index.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction createParser(onParse) {\n  let isFirstChunk;\n  let buffer;\n  let startingPosition;\n  let startingFieldLength;\n  let eventId;\n  let eventName;\n  let data;\n  reset();\n  return {\n    feed,\n    reset\n  };\n  function reset() {\n    isFirstChunk = true;\n    buffer = \"\";\n    startingPosition = 0;\n    startingFieldLength = -1;\n    eventId = void 0;\n    eventName = void 0;\n    data = \"\";\n  }\n  function feed(chunk) {\n    buffer = buffer ? buffer + chunk : chunk;\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length);\n    }\n    isFirstChunk = false;\n    const length = buffer.length;\n    let position = 0;\n    let discardTrailingNewline = false;\n    while (position < length) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === \"\\n\") {\n          ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineLength = -1;\n      let fieldLength = startingFieldLength;\n      let character;\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index];\n        if (character === \":\" && fieldLength < 0) {\n          fieldLength = index - position;\n        } else if (character === \"\\r\") {\n          discardTrailingNewline = true;\n          lineLength = index - position;\n        } else if (character === \"\\n\") {\n          lineLength = index - position;\n        }\n      }\n      if (lineLength < 0) {\n        startingPosition = length - position;\n        startingFieldLength = fieldLength;\n        break;\n      } else {\n        startingPosition = 0;\n        startingFieldLength = -1;\n      }\n      parseEventStreamLine(buffer, position, fieldLength, lineLength);\n      position += lineLength + 1;\n    }\n    if (position === length) {\n      buffer = \"\";\n    } else if (position > 0) {\n      buffer = buffer.slice(position);\n    }\n  }\n  function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        onParse({\n          type: \"event\",\n          id: eventId,\n          event: eventName || void 0,\n          data: data.slice(0, -1)\n          // remove trailing newline\n        });\n\n        data = \"\";\n        eventId = void 0;\n      }\n      eventName = void 0;\n      return;\n    }\n    const noValue = fieldLength < 0;\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));\n    let step = 0;\n    if (noValue) {\n      step = lineLength;\n    } else if (lineBuffer[index + fieldLength + 1] === \" \") {\n      step = fieldLength + 2;\n    } else {\n      step = fieldLength + 1;\n    }\n    const position = index + step;\n    const valueLength = lineLength - step;\n    const value = lineBuffer.slice(position, position + valueLength).toString();\n    if (field === \"data\") {\n      data += value ? \"\".concat(value, \"\\n\") : \"\\n\";\n    } else if (field === \"event\") {\n      eventName = value;\n    } else if (field === \"id\" && !value.includes(\"\\0\")) {\n      eventId = value;\n    } else if (field === \"retry\") {\n      const retry = parseInt(value, 10);\n      if (!Number.isNaN(retry)) {\n        onParse({\n          type: \"reconnect-interval\",\n          value: retry\n        });\n      }\n    }\n  }\n}\nconst BOM = [239, 187, 191];\nfunction hasBom(buffer) {\n  return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);\n}\nexports.createParser = createParser;\n//# sourceMappingURL=index.cjs.map\n\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/eventsource-parser/dist/index.cjs?\n}");

/***/ }),

/***/ "./node_modules/robot3/dist/machine.js":
/*!*********************************************!*\
  !*** ./node_modules/robot3/dist/machine.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction valueEnumerable(value) {\n  return { enumerable: true, value };\n}\n\nfunction valueEnumerableWritable(value) {\n  return { enumerable: true, writable: true, value };\n}\n\nlet d = {};\nlet truthy = () => true;\nlet empty = () => ({});\nlet identity = a => a;\nlet callBoth = (par, fn, self, args) => par.apply(self, args) && fn.apply(self, args);\nlet callForward = (par, fn, self, [a, b]) => fn.call(self, par.call(self, a, b), b);\nlet create = (a, b) => Object.freeze(Object.create(a, b));\n\nfunction stack(fns, def, caller) {\n  return fns.reduce((par, fn) => {\n    return function(...args) {\n      return caller(par, fn, this, args);\n    };\n  }, def);\n}\n\nfunction fnType(fn) {\n  return create(this, { fn: valueEnumerable(fn) });\n}\n\nlet reduceType = {};\nlet reduce = fnType.bind(reduceType);\nlet action = fn => reduce((ctx, ev) => !!~fn(ctx, ev) && ctx);\n\nlet guardType = {};\nlet guard = fnType.bind(guardType);\n\nfunction filter(Type, arr) {\n  return arr.filter(value => Type.isPrototypeOf(value));\n}\n\nfunction makeTransition(from, to, ...args) {\n  let guards = stack(filter(guardType, args).map(t => t.fn), truthy, callBoth);\n  let reducers = stack(filter(reduceType, args).map(t => t.fn), identity, callForward);\n  return create(this, {\n    from: valueEnumerable(from),\n    to: valueEnumerable(to),\n    guards: valueEnumerable(guards),\n    reducers: valueEnumerable(reducers)\n  });\n}\n\nlet transitionType = {};\nlet immediateType = {};\nlet transition = makeTransition.bind(transitionType);\nlet immediate = makeTransition.bind(immediateType, null);\n\nfunction enterImmediate(machine, service, event) {\n  return transitionTo(service, machine, event, this.immediates) || machine;\n}\n\nfunction transitionsToMap(transitions) {\n  let m = new Map();\n  for(let t of transitions) {\n    if(!m.has(t.from)) m.set(t.from, []);\n    m.get(t.from).push(t);\n  }\n  return m;\n}\n\nlet stateType = { enter: identity };\nfunction state(...args) {\n  let transitions = filter(transitionType, args);\n  let immediates = filter(immediateType, args);\n  let desc = {\n    final: valueEnumerable(args.length === 0),\n    transitions: valueEnumerable(transitionsToMap(transitions))\n  };\n  if(immediates.length) {\n    desc.immediates = valueEnumerable(immediates);\n    desc.enter = valueEnumerable(enterImmediate);\n  }\n  return create(stateType, desc);\n}\n\nlet invokeFnType = {\n  enter(machine2, service, event) {\n    let rn = this.fn.call(service, service.context, event);\n    if(machine.isPrototypeOf(rn))\n      return create(invokeMachineType, {\n        machine: valueEnumerable(rn),\n        transitions: valueEnumerable(this.transitions)\n      }).enter(machine2, service, event)\n    rn.then(data => service.send({ type: 'done', data }))\n      .catch(error => service.send({ type: 'error', error }));\n    return machine2;\n  }\n};\nlet invokeMachineType = {\n  enter(machine, service, event) {\n    service.child = interpret(this.machine, s => {\n      service.onChange(s);\n      if(service.child == s && s.machine.state.value.final) {\n        delete service.child;\n        service.send({ type: 'done', data: s.context });\n      }\n    }, service.context, event);\n    if(service.child.machine.state.value.final) {\n      let data = service.child.context;\n      delete service.child;\n      return transitionTo(service, machine, { type: 'done', data }, this.transitions.get('done'));\n    }\n    return machine;\n  }\n};\nfunction invoke(fn, ...transitions) {\n  let t = valueEnumerable(transitionsToMap(transitions));\n  return machine.isPrototypeOf(fn) ?\n    create(invokeMachineType, {\n      machine: valueEnumerable(fn),\n      transitions: t\n    }) :\n    create(invokeFnType, {\n      fn: valueEnumerable(fn),\n      transitions: t\n    });\n}\n\nlet machine = {\n  get state() {\n    return {\n      name: this.current,\n      value: this.states[this.current]\n    };\n  }\n};\n\nfunction createMachine(current, states, contextFn = empty) {\n  if(typeof current !== 'string') {\n    contextFn = states || empty;\n    states = current;\n    current = Object.keys(states)[0];\n  }\n  if(d._create) d._create(current, states);\n  return create(machine, {\n    context: valueEnumerable(contextFn),\n    current: valueEnumerable(current),\n    states: valueEnumerable(states)\n  });\n}\n\nfunction transitionTo(service, machine, fromEvent, candidates) {\n  let { context } = service;\n  for(let { to, guards, reducers } of candidates) {  \n    if(guards(context, fromEvent)) {\n      service.context = reducers.call(service, context, fromEvent);\n\n      let original = machine.original || machine;\n      let newMachine = create(original, {\n        current: valueEnumerable(to),\n        original: { value: original }\n      });\n\n      if (d._onEnter) d._onEnter(machine, to, service.context, context, fromEvent);\n      let state = newMachine.state.value;\n      return state.enter(newMachine, service, fromEvent);\n    }\n  }\n}\n\nfunction send(service, event) {\n  let eventName = event.type || event;\n  let { machine } = service;\n  let { value: state, name: currentStateName } = machine.state;\n  \n  if(state.transitions.has(eventName)) {\n    return transitionTo(service, machine, event, state.transitions.get(eventName)) || machine;\n  } else {\n    if(d._send) d._send(eventName, currentStateName);\n  }\n  return machine;\n}\n\nlet service = {\n  send(event) {\n    this.machine = send(this, event);\n    \n    // TODO detect change\n    this.onChange(this);\n  }\n};\n\nfunction interpret(machine, onChange, initialContext, event) {\n  let s = Object.create(service, {\n    machine: valueEnumerableWritable(machine),\n    context: valueEnumerableWritable(machine.context(initialContext, event)),\n    onChange: valueEnumerable(onChange)\n  });\n  s.send = s.send.bind(s);\n  s.machine = s.machine.state.value.enter(s.machine, s, event);\n  return s;\n}\n\nexports.action = action;\nexports.createMachine = createMachine;\nexports.d = d;\nexports.guard = guard;\nexports.immediate = immediate;\nexports.interpret = interpret;\nexports.invoke = invoke;\nexports.reduce = reduce;\nexports.state = state;\nexports.transition = transition;\n\n\n//# sourceURL=webpack://FalAIClientBundled/./node_modules/robot3/dist/machine.js?\n}");

/***/ }),

/***/ "./src/fal-client-bundled.js":
/*!***********************************!*\
  !*** ./src/fal-client-bundled.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _fal_ai_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fal-ai/client */ \"./node_modules/@fal-ai/client/src/index.js\");\n/* harmony import */ var _fal_ai_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fal_ai_client__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// Configure the client to work in CEP environment\nvar FalAIClientBundled = {\n  /**\n   * Configure FAL.ai client with API key\n   */\n  configure: function configure(apiKey) {\n    _fal_ai_client__WEBPACK_IMPORTED_MODULE_0__.fal.config({\n      credentials: apiKey\n    });\n  },\n  /**\n   * Upload file to FAL.ai storage using official client\n   */\n  uploadFile: function uploadFile(filePath, apiKey, callback) {\n    console.log('DEBUG: Using official FAL.ai storage upload for:', filePath);\n\n    // Configure the client\n    this.configure(apiKey);\n\n    // Read file from path (for CEP environment)\n    fetch('file://' + filePath).then(function (response) {\n      return response.blob();\n    }).then(function (blob) {\n      // Create File object\n      var fileName = filePath.split('/').pop() || filePath.split('\\\\').pop();\n      var file = new File([blob], fileName, {\n        type: blob.type || 'video/mp4'\n      });\n      console.log('DEBUG: Uploading file via fal.storage.upload:', file.name, 'Size:', file.size);\n\n      // Use official FAL.ai storage upload\n      return _fal_ai_client__WEBPACK_IMPORTED_MODULE_0__.fal.storage.upload(file);\n    }).then(function (url) {\n      console.log('DEBUG: Official upload successful:', url);\n      callback(null, url);\n    })[\"catch\"](function (error) {\n      console.log('DEBUG: Official upload failed:', error.message);\n      callback(error.message);\n    });\n  },\n  /**\n   * Submit job to FAL.ai wan-vace model using official client (cheaper than wan-vace-14b)\n   */\n  submitJob: function submitJob(params, callback) {\n    console.log('DEBUG: Submitting job to wan-vace via official client');\n\n    // Configure the client\n    this.configure(params.apiKey);\n\n    // Submit job using official client with simplified wan-vace parameters\n    var inputData = {\n      prompt: params.prompt\n    };\n\n    // Add optional parameters only if they exist\n    if (params.sourceUrl) {\n      inputData.video_url = params.sourceUrl;\n    }\n    if (params.maskUrl) {\n      inputData.mask_video_url = params.maskUrl;\n    }\n    if (params.negative_prompt) {\n      inputData.negative_prompt = params.negative_prompt;\n    }\n\n    // Add core parameters with defaults\n    inputData.task = \"inpainting\";\n    inputData.num_frames = 81;\n    inputData.frames_per_second = Math.min(Math.max(params.fps || 16, 5), 24); // Clamp between 5-24\n    inputData.resolution = params.resolution || \"720p\";\n    inputData.aspect_ratio = params.aspect_ratio || \"16:9\";\n    inputData.num_inference_steps = params.num_inference_steps || 30;\n    inputData.shift = 5;\n    inputData.enable_safety_checker = true;\n    inputData.enable_prompt_expansion = true;\n    console.log('DEBUG: Sending wan-vace request with input:', JSON.stringify(inputData));\n    _fal_ai_client__WEBPACK_IMPORTED_MODULE_0__.fal.subscribe(\"fal-ai/wan-vace\", {\n      input: inputData,\n      logs: true,\n      onQueueUpdate: function onQueueUpdate(update) {\n        if (update.status === \"IN_PROGRESS\") {\n          var _update$logs;\n          console.log('DEBUG: Job in progress:', (_update$logs = update.logs) === null || _update$logs === void 0 ? void 0 : _update$logs.map(function (log) {\n            return log.message;\n          }).join(', '));\n        }\n      }\n    }).then(function (result) {\n      var _result$data;\n      console.log('DEBUG: Job completed successfully:', result.data);\n      console.log('DEBUG: Result video URL:', (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.video) === null || _result$data === void 0 ? void 0 : _result$data.url);\n      callback(null, result.data);\n    })[\"catch\"](function (error) {\n      console.log('DEBUG: Job submission failed:', error.message);\n      console.log('DEBUG: Full error:', error);\n      callback(error);\n    });\n  },\n  /**\n   * Check job status using official client\n   */\n  checkJobStatus: function checkJobStatus(requestId, apiKey, callback) {\n    console.log('DEBUG: Checking job status via official client:', requestId);\n\n    // Configure the client\n    this.configure(apiKey);\n\n    // Check status using official client (wan-vace model)\n    _fal_ai_client__WEBPACK_IMPORTED_MODULE_0__.fal.queue.status(\"fal-ai/wan-vace\", {\n      requestId: requestId,\n      logs: true\n    }).then(function (status) {\n      console.log('DEBUG: Job status:', status);\n      callback(null, status);\n    })[\"catch\"](function (error) {\n      console.log('DEBUG: Status check failed:', error.message);\n      callback(error);\n    });\n  },\n  /**\n   * Download file from URL using modern fetch API\n   */\n  downloadFile: function downloadFile(url, outputPath, callback) {\n    console.log('DEBUG: Starting download from:', url);\n    console.log('DEBUG: Download target path:', outputPath);\n    fetch(url).then(function (response) {\n      console.log('DEBUG: Fetch response status:', response.status);\n      console.log('DEBUG: Fetch response headers:', response.headers);\n      if (!response.ok) {\n        throw new Error('Download failed with status: ' + response.status);\n      }\n      return response.blob();\n    }).then(function (blob) {\n      console.log('DEBUG: Blob received, size:', blob.size, 'type:', blob.type);\n      console.log('DEBUG: Downloading file directly without base64 conversion...');\n\n      // Use direct file download via ExtendScript instead of base64 conversion\n      var script = \"saveFileFromUrl(\\\"\".concat(url, \"\\\", \\\"\").concat(outputPath, \"\\\")\");\n      console.log('DEBUG: Calling ExtendScript saveFileFromUrl...');\n      if (typeof csInterface !== 'undefined') {\n        csInterface.evalScript(script, function (result) {\n          console.log('DEBUG: ExtendScript result:', result);\n          if (result.startsWith('ERROR:')) {\n            callback(result.substring(6));\n          } else {\n            console.log('DEBUG: File downloaded and saved successfully');\n            callback(null);\n          }\n        });\n      } else {\n        console.log('DEBUG: ERROR - CEP interface not available');\n        callback('CEP interface not available');\n      }\n    })[\"catch\"](function (error) {\n      console.log('DEBUG: Download fetch failed:', error.message);\n      console.log('DEBUG: Full download error:', error);\n      callback(error.message);\n    });\n  }\n};\n\n// Export for webpack\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FalAIClientBundled);\n\n//# sourceURL=webpack://FalAIClientBundled/./src/fal-client-bundled.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/fal-client-bundled.js");
/******/ 	window.FalAIClientBundled = __webpack_exports__;
/******/ 	
/******/ })()
;